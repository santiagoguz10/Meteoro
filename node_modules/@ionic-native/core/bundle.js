'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var rxjs = require('rxjs');

function checkReady() {
    if (typeof process === 'undefined') {
        var win_1 = typeof window !== 'undefined' ? window : {};
        var DEVICE_READY_TIMEOUT_1 = 5000;
        // To help developers using cordova, we listen for the device ready event and
        // log an error if it didn't fire in a reasonable amount of time. Generally,
        // when this happens, developers should remove and reinstall plugins, since
        // an inconsistent plugin is often the culprit.
        var before_1 = Date.now();
        var didFireReady_1 = false;
        win_1.document.addEventListener('deviceready', function () {
            console.log("Ionic Native: deviceready event fired after " + (Date.now() - before_1) + " ms");
            didFireReady_1 = true;
        });
        setTimeout(function () {
            if (!didFireReady_1 && win_1.cordova) {
                console.warn("Ionic Native: deviceready did not fire within " + DEVICE_READY_TIMEOUT_1 + "ms. This can happen when plugins are in an inconsistent state. Try removing plugins from plugins/ and reinstalling them.");
            }
        }, DEVICE_READY_TIMEOUT_1);
    }
}

var ERR_CORDOVA_NOT_AVAILABLE = { error: 'cordova_not_available' };
var ERR_PLUGIN_NOT_INSTALLED = { error: 'plugin_not_installed' };
function getPromise(callback) {
    var tryNativePromise = function () {
        if (Promise) {
            return new Promise(function (resolve, reject) {
                callback(resolve, reject);
            });
        }
        else {
            console.error('No Promise support or polyfill found. To enable Ionic Native support, please add the es6-promise polyfill before this script, or run with a library like Angular or on a recent browser.');
        }
    };
    if (typeof window !== 'undefined' && window.angular) {
        var doc = window.document;
        var injector = window.angular.element(doc.querySelector('[ng-app]') || doc.body).injector();
        if (injector) {
            var $q = injector.get('$q');
            return $q(function (resolve, reject) {
                callback(resolve, reject);
            });
        }
        console.warn("Angular 1 was detected but $q couldn't be retrieved. This is usually when the app is not bootstrapped on the html or body tag. Falling back to native promises which won't trigger an automatic digest when promises resolve.");
    }
    return tryNativePromise();
}
function wrapPromise(pluginObj, methodName, args, opts) {
    if (opts === void 0) { opts = {}; }
    var pluginResult, rej;
    var p = getPromise(function (resolve, reject) {
        if (opts.destruct) {
            pluginResult = callCordovaPlugin(pluginObj, methodName, args, opts, function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                return resolve(args);
            }, function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                return reject(args);
            });
        }
        else {
            pluginResult = callCordovaPlugin(pluginObj, methodName, args, opts, resolve, reject);
        }
        rej = reject;
    });
    // Angular throws an error on unhandled rejection, but in this case we have already printed
    // a warning that Cordova is undefined or the plugin is uninstalled, so there is no reason
    // to error
    if (pluginResult && pluginResult.error) {
        p.catch(function () { });
        typeof rej === 'function' && rej(pluginResult.error);
    }
    return p;
}
function wrapOtherPromise(pluginObj, methodName, args, opts) {
    if (opts === void 0) { opts = {}; }
    return getPromise(function (resolve, reject) {
        var pluginResult = callCordovaPlugin(pluginObj, methodName, args, opts);
        if (pluginResult) {
            if (pluginResult.error) {
                reject(pluginResult.error);
            }
            else if (pluginResult.then) {
                pluginResult.then(resolve).catch(reject);
            }
        }
        else {
            reject({ error: 'unexpected_error' });
        }
    });
}
function wrapObservable(pluginObj, methodName, args, opts) {
    if (opts === void 0) { opts = {}; }
    return new rxjs.Observable(function (observer) {
        var pluginResult;
        if (opts.destruct) {
            pluginResult = callCordovaPlugin(pluginObj, methodName, args, opts, function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                return observer.next(args);
            }, function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                return observer.error(args);
            });
        }
        else {
            pluginResult = callCordovaPlugin(pluginObj, methodName, args, opts, observer.next.bind(observer), observer.error.bind(observer));
        }
        if (pluginResult && pluginResult.error) {
            observer.error(pluginResult.error);
            observer.complete();
        }
        return function () {
            try {
                if (opts.clearFunction) {
                    if (opts.clearWithArgs) {
                        return callCordovaPlugin(pluginObj, opts.clearFunction, args, opts, observer.next.bind(observer), observer.error.bind(observer));
                    }
                    return callCordovaPlugin(pluginObj, opts.clearFunction, []);
                }
            }
            catch (e) {
                console.warn('Unable to clear the previous observable watch for', pluginObj.constructor.getPluginName(), methodName);
                console.warn(e);
            }
        };
    });
}
/**
 * Wrap the event with an observable
 * @private
 * @param event event name
 * @param element The element to attach the event listener to
 * @returns {Observable}
 */
function wrapEventObservable(event, element) {
    element =
        typeof window !== 'undefined' && element
            ? get$1(window, element)
            : element || (typeof window !== 'undefined' ? window : {});
    return rxjs.fromEvent(element, event);
}
function checkAvailability(plugin, methodName, pluginName) {
    var pluginRef, pluginInstance, pluginPackage;
    if (typeof plugin === 'string') {
        pluginRef = plugin;
    }
    else {
        pluginRef = plugin.constructor.getPluginRef();
        pluginName = plugin.constructor.getPluginName();
        pluginPackage = plugin.constructor.getPluginInstallName();
    }
    pluginInstance = getPlugin(pluginRef);
    if (!pluginInstance || (!!methodName && typeof pluginInstance[methodName] === 'undefined')) {
        if (typeof window === 'undefined' || !window.cordova) {
            cordovaWarn(pluginName, methodName);
            return ERR_CORDOVA_NOT_AVAILABLE;
        }
        pluginWarn(pluginName, pluginPackage, methodName);
        return ERR_PLUGIN_NOT_INSTALLED;
    }
    return true;
}
/**
 * Checks if _objectInstance exists and has the method/property
 * @private
 */
function instanceAvailability(pluginObj, methodName) {
    return pluginObj._objectInstance && (!methodName || typeof pluginObj._objectInstance[methodName] !== 'undefined');
}
function setIndex(args, opts, resolve, reject) {
    if (opts === void 0) { opts = {}; }
    // ignore resolve and reject in case sync
    if (opts.sync) {
        return args;
    }
    // If the plugin method expects myMethod(success, err, options)
    if (opts.callbackOrder === 'reverse') {
        // Get those arguments in the order [resolve, reject, ...restOfArgs]
        args.unshift(reject);
        args.unshift(resolve);
    }
    else if (opts.callbackStyle === 'node') {
        args.push(function (err, result) {
            if (err) {
                reject(err);
            }
            else {
                resolve(result);
            }
        });
    }
    else if (opts.callbackStyle === 'object' && opts.successName && opts.errorName) {
        var obj = {};
        obj[opts.successName] = resolve;
        obj[opts.errorName] = reject;
        args.push(obj);
    }
    else if (typeof opts.successIndex !== 'undefined' || typeof opts.errorIndex !== 'undefined') {
        var setSuccessIndex = function () {
            // If we've specified a success/error index
            if (opts.successIndex > args.length) {
                args[opts.successIndex] = resolve;
            }
            else {
                args.splice(opts.successIndex, 0, resolve);
            }
        };
        var setErrorIndex = function () {
            // We don't want that the reject cb gets spliced into the position of an optional argument that has not been
            // defined and thus causing non expected behavior.
            if (opts.errorIndex > args.length) {
                args[opts.errorIndex] = reject; // insert the reject fn at the correct specific index
            }
            else {
                args.splice(opts.errorIndex, 0, reject); // otherwise just splice it into the array
            }
        };
        if (opts.successIndex > opts.errorIndex) {
            setErrorIndex();
            setSuccessIndex();
        }
        else {
            setSuccessIndex();
            setErrorIndex();
        }
    }
    else {
        // Otherwise, let's tack them on to the end of the argument list
        // which is 90% of cases
        args.push(resolve);
        args.push(reject);
    }
    return args;
}
function callCordovaPlugin(pluginObj, methodName, args, opts, resolve, reject) {
    if (opts === void 0) { opts = {}; }
    // Try to figure out where the success/error callbacks need to be bound
    // to our promise resolve/reject handlers.
    args = setIndex(args, opts, resolve, reject);
    var availabilityCheck = checkAvailability(pluginObj, methodName);
    if (availabilityCheck === true) {
        var pluginInstance = getPlugin(pluginObj.constructor.getPluginRef());
        return pluginInstance[methodName].apply(pluginInstance, args);
    }
    else {
        return availabilityCheck;
    }
}
function callInstance(pluginObj, methodName, args, opts, resolve, reject) {
    if (opts === void 0) { opts = {}; }
    args = setIndex(args, opts, resolve, reject);
    if (instanceAvailability(pluginObj, methodName)) {
        return pluginObj._objectInstance[methodName].apply(pluginObj._objectInstance, args);
    }
}
function getPlugin(pluginRef) {
    if (typeof window !== 'undefined') {
        return get$1(window, pluginRef);
    }
    return null;
}
function get$1(element, path) {
    var paths = path.split('.');
    var obj = element;
    for (var i = 0; i < paths.length; i++) {
        if (!obj) {
            return null;
        }
        obj = obj[paths[i]];
    }
    return obj;
}
function pluginWarn(pluginName, plugin, method) {
    if (method) {
        console.warn('Native: tried calling ' + pluginName + '.' + method + ', but the ' + pluginName + ' plugin is not installed.');
    }
    else {
        console.warn("Native: tried accessing the " + pluginName + " plugin but it's not installed.");
    }
    if (plugin) {
        console.warn("Install the " + pluginName + " plugin: 'ionic cordova plugin add " + plugin + "'");
    }
}
/**
 * @private
 * @param pluginName
 * @param method
 */
function cordovaWarn(pluginName, method) {
    if (typeof process === 'undefined') {
        if (method) {
            console.warn('Native: tried calling ' +
                pluginName +
                '.' +
                method +
                ', but Cordova is not available. Make sure to include cordova.js or run in a device/simulator');
        }
        else {
            console.warn('Native: tried accessing the ' +
                pluginName +
                ' plugin but Cordova is not available. Make sure to include cordova.js or run in a device/simulator');
        }
    }
}
/**
 * @private
 */
var wrap = function (pluginObj, methodName, opts) {
    if (opts === void 0) { opts = {}; }
    return function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        if (opts.sync) {
            // Sync doesn't wrap the plugin with a promise or observable, it returns the result as-is
            return callCordovaPlugin(pluginObj, methodName, args, opts);
        }
        else if (opts.observable) {
            return wrapObservable(pluginObj, methodName, args, opts);
        }
        else if (opts.eventObservable && opts.event) {
            return wrapEventObservable(opts.event, opts.element);
        }
        else if (opts.otherPromise) {
            return wrapOtherPromise(pluginObj, methodName, args, opts);
        }
        else {
            return wrapPromise(pluginObj, methodName, args, opts);
        }
    };
};
/**
 * @private
 */
function wrapInstance(pluginObj, methodName, opts) {
    if (opts === void 0) { opts = {}; }
    return function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        if (opts.sync) {
            return callInstance(pluginObj, methodName, args, opts);
        }
        else if (opts.observable) {
            return new rxjs.Observable(function (observer) {
                var pluginResult;
                if (opts.destruct) {
                    pluginResult = callInstance(pluginObj, methodName, args, opts, function () {
                        var args = [];
                        for (var _i = 0; _i < arguments.length; _i++) {
                            args[_i] = arguments[_i];
                        }
                        return observer.next(args);
                    }, function () {
                        var args = [];
                        for (var _i = 0; _i < arguments.length; _i++) {
                            args[_i] = arguments[_i];
                        }
                        return observer.error(args);
                    });
                }
                else {
                    pluginResult = callInstance(pluginObj, methodName, args, opts, observer.next.bind(observer), observer.error.bind(observer));
                }
                if (pluginResult && pluginResult.error) {
                    observer.error(pluginResult.error);
                }
                return function () {
                    try {
                        if (opts.clearWithArgs) {
                            return callInstance(pluginObj, opts.clearFunction, args, opts, observer.next.bind(observer), observer.error.bind(observer));
                        }
                        return callInstance(pluginObj, opts.clearFunction, []);
                    }
                    catch (e) {
                        console.warn('Unable to clear the previous observable watch for', pluginObj.constructor.getPluginName(), methodName);
                        console.warn(e);
                    }
                };
            });
        }
        else if (opts.otherPromise) {
            return getPromise(function (resolve, reject) {
                var result;
                if (opts.destruct) {
                    result = callInstance(pluginObj, methodName, args, opts, function () {
                        var args = [];
                        for (var _i = 0; _i < arguments.length; _i++) {
                            args[_i] = arguments[_i];
                        }
                        return resolve(args);
                    }, function () {
                        var args = [];
                        for (var _i = 0; _i < arguments.length; _i++) {
                            args[_i] = arguments[_i];
                        }
                        return reject(args);
                    });
                }
                else {
                    result = callInstance(pluginObj, methodName, args, opts, resolve, reject);
                }
                if (result && result.then) {
                    result.then(resolve, reject);
                }
                else {
                    reject();
                }
            });
        }
        else {
            var pluginResult_1, rej_1;
            var p = getPromise(function (resolve, reject) {
                if (opts.destruct) {
                    pluginResult_1 = callInstance(pluginObj, methodName, args, opts, function () {
                        var args = [];
                        for (var _i = 0; _i < arguments.length; _i++) {
                            args[_i] = arguments[_i];
                        }
                        return resolve(args);
                    }, function () {
                        var args = [];
                        for (var _i = 0; _i < arguments.length; _i++) {
                            args[_i] = arguments[_i];
                        }
                        return reject(args);
                    });
                }
                else {
                    pluginResult_1 = callInstance(pluginObj, methodName, args, opts, resolve, reject);
                }
                rej_1 = reject;
            });
            // Angular throws an error on unhandled rejection, but in this case we have already printed
            // a warning that Cordova is undefined or the plugin is uninstalled, so there is no reason
            // to error
            if (pluginResult_1 && pluginResult_1.error) {
                p.catch(function () { });
                typeof rej_1 === 'function' && rej_1(pluginResult_1.error);
            }
            return p;
        }
    };
}

/**
 * @private
 */
function get(element, path) {
    var paths = path.split('.');
    var obj = element;
    for (var i = 0; i < paths.length; i++) {
        if (!obj) {
            return null;
        }
        obj = obj[paths[i]];
    }
    return obj;
}

var IonicNativePlugin = /** @class */ (function () {
    function IonicNativePlugin() {
    }
    /**
     * Returns a boolean that indicates whether the plugin is installed
     * @return {boolean}
     */
    IonicNativePlugin.installed = function () {
        var isAvailable = checkAvailability(this.pluginRef) === true;
        return isAvailable;
    };
    /**
     * Returns the original plugin object
     */
    IonicNativePlugin.getPlugin = function () {
        if (typeof window !== 'undefined') {
            return get(window, this.pluginRef);
        }
        return null;
    };
    /**
     * Returns the plugin's name
     */
    IonicNativePlugin.getPluginName = function () {
        var pluginName = this.pluginName;
        return pluginName;
    };
    /**
     * Returns the plugin's reference
     */
    IonicNativePlugin.getPluginRef = function () {
        var pluginRef = this.pluginRef;
        return pluginRef;
    };
    /**
     * Returns the plugin's install name
     */
    IonicNativePlugin.getPluginInstallName = function () {
        var plugin = this.plugin;
        return plugin;
    };
    /**
     * Returns the plugin's supported platforms
     */
    IonicNativePlugin.getSupportedPlatforms = function () {
        var platform = this.platforms;
        return platform;
    };
    IonicNativePlugin.pluginName = '';
    IonicNativePlugin.pluginRef = '';
    IonicNativePlugin.plugin = '';
    IonicNativePlugin.repo = '';
    IonicNativePlugin.platforms = [];
    IonicNativePlugin.install = '';
    return IonicNativePlugin;
}());

function cordova(pluginObj, methodName, config, args) {
    return wrap(pluginObj, methodName, config).apply(this, args);
}

function overrideFunction(pluginObj, methodName) {
    return new rxjs.Observable(function (observer) {
        var availabilityCheck = checkAvailability(pluginObj, methodName);
        if (availabilityCheck === true) {
            var pluginInstance_1 = getPlugin(pluginObj.constructor.getPluginRef());
            pluginInstance_1[methodName] = observer.next.bind(observer);
            return function () { return (pluginInstance_1[methodName] = function () { }); };
        }
        else {
            observer.error(availabilityCheck);
            observer.complete();
        }
    });
}
function cordovaFunctionOverride(pluginObj, methodName, args) {
    return overrideFunction(pluginObj, methodName);
}

function cordovaInstance(pluginObj, methodName, config, args) {
    args = Array.from(args);
    return wrapInstance(pluginObj, methodName, config).apply(this, args);
}

function cordovaPropertyGet(pluginObj, key) {
    if (checkAvailability(pluginObj, key) === true) {
        return getPlugin(pluginObj.constructor.getPluginRef())[key];
    }
    return null;
}
function cordovaPropertySet(pluginObj, key, value) {
    if (checkAvailability(pluginObj, key) === true) {
        getPlugin(pluginObj.constructor.getPluginRef())[key] = value;
    }
}

function instancePropertyGet(pluginObj, key) {
    if (pluginObj._objectInstance && pluginObj._objectInstance[key]) {
        return pluginObj._objectInstance[key];
    }
    return null;
}
function instancePropertySet(pluginObj, key, value) {
    if (pluginObj._objectInstance) {
        pluginObj._objectInstance[key] = value;
    }
}

checkReady();

exports.IonicNativePlugin = IonicNativePlugin;
exports.checkAvailability = checkAvailability;
exports.cordova = cordova;
exports.cordovaFunctionOverride = cordovaFunctionOverride;
exports.cordovaInstance = cordovaInstance;
exports.cordovaPropertyGet = cordovaPropertyGet;
exports.cordovaPropertySet = cordovaPropertySet;
exports.getPromise = getPromise;
exports.instanceAvailability = instanceAvailability;
exports.instancePropertyGet = instancePropertyGet;
exports.instancePropertySet = instancePropertySet;
exports.wrap = wrap;

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYnVuZGxlLmpzIiwic291cmNlcyI6WyJidW5kbGUuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG52YXIgcnhqcyA9IHJlcXVpcmUoJ3J4anMnKTtcblxuZnVuY3Rpb24gY2hlY2tSZWFkeSgpIHtcbiAgICBpZiAodHlwZW9mIHByb2Nlc3MgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHZhciB3aW5fMSA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93IDoge307XG4gICAgICAgIHZhciBERVZJQ0VfUkVBRFlfVElNRU9VVF8xID0gNTAwMDtcbiAgICAgICAgLy8gVG8gaGVscCBkZXZlbG9wZXJzIHVzaW5nIGNvcmRvdmEsIHdlIGxpc3RlbiBmb3IgdGhlIGRldmljZSByZWFkeSBldmVudCBhbmRcbiAgICAgICAgLy8gbG9nIGFuIGVycm9yIGlmIGl0IGRpZG4ndCBmaXJlIGluIGEgcmVhc29uYWJsZSBhbW91bnQgb2YgdGltZS4gR2VuZXJhbGx5LFxuICAgICAgICAvLyB3aGVuIHRoaXMgaGFwcGVucywgZGV2ZWxvcGVycyBzaG91bGQgcmVtb3ZlIGFuZCByZWluc3RhbGwgcGx1Z2lucywgc2luY2VcbiAgICAgICAgLy8gYW4gaW5jb25zaXN0ZW50IHBsdWdpbiBpcyBvZnRlbiB0aGUgY3VscHJpdC5cbiAgICAgICAgdmFyIGJlZm9yZV8xID0gRGF0ZS5ub3coKTtcbiAgICAgICAgdmFyIGRpZEZpcmVSZWFkeV8xID0gZmFsc2U7XG4gICAgICAgIHdpbl8xLmRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2RldmljZXJlYWR5JywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCJJb25pYyBOYXRpdmU6IGRldmljZXJlYWR5IGV2ZW50IGZpcmVkIGFmdGVyIFwiICsgKERhdGUubm93KCkgLSBiZWZvcmVfMSkgKyBcIiBtc1wiKTtcbiAgICAgICAgICAgIGRpZEZpcmVSZWFkeV8xID0gdHJ1ZTtcbiAgICAgICAgfSk7XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKCFkaWRGaXJlUmVhZHlfMSAmJiB3aW5fMS5jb3Jkb3ZhKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwiSW9uaWMgTmF0aXZlOiBkZXZpY2VyZWFkeSBkaWQgbm90IGZpcmUgd2l0aGluIFwiICsgREVWSUNFX1JFQURZX1RJTUVPVVRfMSArIFwibXMuIFRoaXMgY2FuIGhhcHBlbiB3aGVuIHBsdWdpbnMgYXJlIGluIGFuIGluY29uc2lzdGVudCBzdGF0ZS4gVHJ5IHJlbW92aW5nIHBsdWdpbnMgZnJvbSBwbHVnaW5zLyBhbmQgcmVpbnN0YWxsaW5nIHRoZW0uXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCBERVZJQ0VfUkVBRFlfVElNRU9VVF8xKTtcbiAgICB9XG59XG5cbnZhciBFUlJfQ09SRE9WQV9OT1RfQVZBSUxBQkxFID0geyBlcnJvcjogJ2NvcmRvdmFfbm90X2F2YWlsYWJsZScgfTtcbnZhciBFUlJfUExVR0lOX05PVF9JTlNUQUxMRUQgPSB7IGVycm9yOiAncGx1Z2luX25vdF9pbnN0YWxsZWQnIH07XG5mdW5jdGlvbiBnZXRQcm9taXNlKGNhbGxiYWNrKSB7XG4gICAgdmFyIHRyeU5hdGl2ZVByb21pc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChQcm9taXNlKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ05vIFByb21pc2Ugc3VwcG9ydCBvciBwb2x5ZmlsbCBmb3VuZC4gVG8gZW5hYmxlIElvbmljIE5hdGl2ZSBzdXBwb3J0LCBwbGVhc2UgYWRkIHRoZSBlczYtcHJvbWlzZSBwb2x5ZmlsbCBiZWZvcmUgdGhpcyBzY3JpcHQsIG9yIHJ1biB3aXRoIGEgbGlicmFyeSBsaWtlIEFuZ3VsYXIgb3Igb24gYSByZWNlbnQgYnJvd3Nlci4nKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5hbmd1bGFyKSB7XG4gICAgICAgIHZhciBkb2MgPSB3aW5kb3cuZG9jdW1lbnQ7XG4gICAgICAgIHZhciBpbmplY3RvciA9IHdpbmRvdy5hbmd1bGFyLmVsZW1lbnQoZG9jLnF1ZXJ5U2VsZWN0b3IoJ1tuZy1hcHBdJykgfHwgZG9jLmJvZHkpLmluamVjdG9yKCk7XG4gICAgICAgIGlmIChpbmplY3Rvcikge1xuICAgICAgICAgICAgdmFyICRxID0gaW5qZWN0b3IuZ2V0KCckcScpO1xuICAgICAgICAgICAgcmV0dXJuICRxKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhyZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc29sZS53YXJuKFwiQW5ndWxhciAxIHdhcyBkZXRlY3RlZCBidXQgJHEgY291bGRuJ3QgYmUgcmV0cmlldmVkLiBUaGlzIGlzIHVzdWFsbHkgd2hlbiB0aGUgYXBwIGlzIG5vdCBib290c3RyYXBwZWQgb24gdGhlIGh0bWwgb3IgYm9keSB0YWcuIEZhbGxpbmcgYmFjayB0byBuYXRpdmUgcHJvbWlzZXMgd2hpY2ggd29uJ3QgdHJpZ2dlciBhbiBhdXRvbWF0aWMgZGlnZXN0IHdoZW4gcHJvbWlzZXMgcmVzb2x2ZS5cIik7XG4gICAgfVxuICAgIHJldHVybiB0cnlOYXRpdmVQcm9taXNlKCk7XG59XG5mdW5jdGlvbiB3cmFwUHJvbWlzZShwbHVnaW5PYmosIG1ldGhvZE5hbWUsIGFyZ3MsIG9wdHMpIHtcbiAgICBpZiAob3B0cyA9PT0gdm9pZCAwKSB7IG9wdHMgPSB7fTsgfVxuICAgIHZhciBwbHVnaW5SZXN1bHQsIHJlajtcbiAgICB2YXIgcCA9IGdldFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBpZiAob3B0cy5kZXN0cnVjdCkge1xuICAgICAgICAgICAgcGx1Z2luUmVzdWx0ID0gY2FsbENvcmRvdmFQbHVnaW4ocGx1Z2luT2JqLCBtZXRob2ROYW1lLCBhcmdzLCBvcHRzLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgICAgICBhcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZlKGFyZ3MpO1xuICAgICAgICAgICAgfSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBhcmdzID0gW107XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICAgICAgYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0KGFyZ3MpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwbHVnaW5SZXN1bHQgPSBjYWxsQ29yZG92YVBsdWdpbihwbHVnaW5PYmosIG1ldGhvZE5hbWUsIGFyZ3MsIG9wdHMsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgIH1cbiAgICAgICAgcmVqID0gcmVqZWN0O1xuICAgIH0pO1xuICAgIC8vIEFuZ3VsYXIgdGhyb3dzIGFuIGVycm9yIG9uIHVuaGFuZGxlZCByZWplY3Rpb24sIGJ1dCBpbiB0aGlzIGNhc2Ugd2UgaGF2ZSBhbHJlYWR5IHByaW50ZWRcbiAgICAvLyBhIHdhcm5pbmcgdGhhdCBDb3Jkb3ZhIGlzIHVuZGVmaW5lZCBvciB0aGUgcGx1Z2luIGlzIHVuaW5zdGFsbGVkLCBzbyB0aGVyZSBpcyBubyByZWFzb25cbiAgICAvLyB0byBlcnJvclxuICAgIGlmIChwbHVnaW5SZXN1bHQgJiYgcGx1Z2luUmVzdWx0LmVycm9yKSB7XG4gICAgICAgIHAuY2F0Y2goZnVuY3Rpb24gKCkgeyB9KTtcbiAgICAgICAgdHlwZW9mIHJlaiA9PT0gJ2Z1bmN0aW9uJyAmJiByZWoocGx1Z2luUmVzdWx0LmVycm9yKTtcbiAgICB9XG4gICAgcmV0dXJuIHA7XG59XG5mdW5jdGlvbiB3cmFwT3RoZXJQcm9taXNlKHBsdWdpbk9iaiwgbWV0aG9kTmFtZSwgYXJncywgb3B0cykge1xuICAgIGlmIChvcHRzID09PSB2b2lkIDApIHsgb3B0cyA9IHt9OyB9XG4gICAgcmV0dXJuIGdldFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICB2YXIgcGx1Z2luUmVzdWx0ID0gY2FsbENvcmRvdmFQbHVnaW4ocGx1Z2luT2JqLCBtZXRob2ROYW1lLCBhcmdzLCBvcHRzKTtcbiAgICAgICAgaWYgKHBsdWdpblJlc3VsdCkge1xuICAgICAgICAgICAgaWYgKHBsdWdpblJlc3VsdC5lcnJvcikge1xuICAgICAgICAgICAgICAgIHJlamVjdChwbHVnaW5SZXN1bHQuZXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocGx1Z2luUmVzdWx0LnRoZW4pIHtcbiAgICAgICAgICAgICAgICBwbHVnaW5SZXN1bHQudGhlbihyZXNvbHZlKS5jYXRjaChyZWplY3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVqZWN0KHsgZXJyb3I6ICd1bmV4cGVjdGVkX2Vycm9yJyB9KTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuZnVuY3Rpb24gd3JhcE9ic2VydmFibGUocGx1Z2luT2JqLCBtZXRob2ROYW1lLCBhcmdzLCBvcHRzKSB7XG4gICAgaWYgKG9wdHMgPT09IHZvaWQgMCkgeyBvcHRzID0ge307IH1cbiAgICByZXR1cm4gbmV3IHJ4anMuT2JzZXJ2YWJsZShmdW5jdGlvbiAob2JzZXJ2ZXIpIHtcbiAgICAgICAgdmFyIHBsdWdpblJlc3VsdDtcbiAgICAgICAgaWYgKG9wdHMuZGVzdHJ1Y3QpIHtcbiAgICAgICAgICAgIHBsdWdpblJlc3VsdCA9IGNhbGxDb3Jkb3ZhUGx1Z2luKHBsdWdpbk9iaiwgbWV0aG9kTmFtZSwgYXJncywgb3B0cywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBhcmdzID0gW107XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICAgICAgYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gb2JzZXJ2ZXIubmV4dChhcmdzKTtcbiAgICAgICAgICAgIH0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgYXJncyA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9ic2VydmVyLmVycm9yKGFyZ3MpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwbHVnaW5SZXN1bHQgPSBjYWxsQ29yZG92YVBsdWdpbihwbHVnaW5PYmosIG1ldGhvZE5hbWUsIGFyZ3MsIG9wdHMsIG9ic2VydmVyLm5leHQuYmluZChvYnNlcnZlciksIG9ic2VydmVyLmVycm9yLmJpbmQob2JzZXJ2ZXIpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGx1Z2luUmVzdWx0ICYmIHBsdWdpblJlc3VsdC5lcnJvcikge1xuICAgICAgICAgICAgb2JzZXJ2ZXIuZXJyb3IocGx1Z2luUmVzdWx0LmVycm9yKTtcbiAgICAgICAgICAgIG9ic2VydmVyLmNvbXBsZXRlKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKG9wdHMuY2xlYXJGdW5jdGlvbikge1xuICAgICAgICAgICAgICAgICAgICBpZiAob3B0cy5jbGVhcldpdGhBcmdzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FsbENvcmRvdmFQbHVnaW4ocGx1Z2luT2JqLCBvcHRzLmNsZWFyRnVuY3Rpb24sIGFyZ3MsIG9wdHMsIG9ic2VydmVyLm5leHQuYmluZChvYnNlcnZlciksIG9ic2VydmVyLmVycm9yLmJpbmQob2JzZXJ2ZXIpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FsbENvcmRvdmFQbHVnaW4ocGx1Z2luT2JqLCBvcHRzLmNsZWFyRnVuY3Rpb24sIFtdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignVW5hYmxlIHRvIGNsZWFyIHRoZSBwcmV2aW91cyBvYnNlcnZhYmxlIHdhdGNoIGZvcicsIHBsdWdpbk9iai5jb25zdHJ1Y3Rvci5nZXRQbHVnaW5OYW1lKCksIG1ldGhvZE5hbWUpO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9KTtcbn1cbi8qKlxuICogV3JhcCB0aGUgZXZlbnQgd2l0aCBhbiBvYnNlcnZhYmxlXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIGV2ZW50IGV2ZW50IG5hbWVcbiAqIEBwYXJhbSBlbGVtZW50IFRoZSBlbGVtZW50IHRvIGF0dGFjaCB0aGUgZXZlbnQgbGlzdGVuZXIgdG9cbiAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfVxuICovXG5mdW5jdGlvbiB3cmFwRXZlbnRPYnNlcnZhYmxlKGV2ZW50LCBlbGVtZW50KSB7XG4gICAgZWxlbWVudCA9XG4gICAgICAgIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIGVsZW1lbnRcbiAgICAgICAgICAgID8gZ2V0JDEod2luZG93LCBlbGVtZW50KVxuICAgICAgICAgICAgOiBlbGVtZW50IHx8ICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6IHt9KTtcbiAgICByZXR1cm4gcnhqcy5mcm9tRXZlbnQoZWxlbWVudCwgZXZlbnQpO1xufVxuZnVuY3Rpb24gY2hlY2tBdmFpbGFiaWxpdHkocGx1Z2luLCBtZXRob2ROYW1lLCBwbHVnaW5OYW1lKSB7XG4gICAgdmFyIHBsdWdpblJlZiwgcGx1Z2luSW5zdGFuY2UsIHBsdWdpblBhY2thZ2U7XG4gICAgaWYgKHR5cGVvZiBwbHVnaW4gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHBsdWdpblJlZiA9IHBsdWdpbjtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHBsdWdpblJlZiA9IHBsdWdpbi5jb25zdHJ1Y3Rvci5nZXRQbHVnaW5SZWYoKTtcbiAgICAgICAgcGx1Z2luTmFtZSA9IHBsdWdpbi5jb25zdHJ1Y3Rvci5nZXRQbHVnaW5OYW1lKCk7XG4gICAgICAgIHBsdWdpblBhY2thZ2UgPSBwbHVnaW4uY29uc3RydWN0b3IuZ2V0UGx1Z2luSW5zdGFsbE5hbWUoKTtcbiAgICB9XG4gICAgcGx1Z2luSW5zdGFuY2UgPSBnZXRQbHVnaW4ocGx1Z2luUmVmKTtcbiAgICBpZiAoIXBsdWdpbkluc3RhbmNlIHx8ICghIW1ldGhvZE5hbWUgJiYgdHlwZW9mIHBsdWdpbkluc3RhbmNlW21ldGhvZE5hbWVdID09PSAndW5kZWZpbmVkJykpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnIHx8ICF3aW5kb3cuY29yZG92YSkge1xuICAgICAgICAgICAgY29yZG92YVdhcm4ocGx1Z2luTmFtZSwgbWV0aG9kTmFtZSk7XG4gICAgICAgICAgICByZXR1cm4gRVJSX0NPUkRPVkFfTk9UX0FWQUlMQUJMRTtcbiAgICAgICAgfVxuICAgICAgICBwbHVnaW5XYXJuKHBsdWdpbk5hbWUsIHBsdWdpblBhY2thZ2UsIG1ldGhvZE5hbWUpO1xuICAgICAgICByZXR1cm4gRVJSX1BMVUdJTl9OT1RfSU5TVEFMTEVEO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbi8qKlxuICogQ2hlY2tzIGlmIF9vYmplY3RJbnN0YW5jZSBleGlzdHMgYW5kIGhhcyB0aGUgbWV0aG9kL3Byb3BlcnR5XG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBpbnN0YW5jZUF2YWlsYWJpbGl0eShwbHVnaW5PYmosIG1ldGhvZE5hbWUpIHtcbiAgICByZXR1cm4gcGx1Z2luT2JqLl9vYmplY3RJbnN0YW5jZSAmJiAoIW1ldGhvZE5hbWUgfHwgdHlwZW9mIHBsdWdpbk9iai5fb2JqZWN0SW5zdGFuY2VbbWV0aG9kTmFtZV0gIT09ICd1bmRlZmluZWQnKTtcbn1cbmZ1bmN0aW9uIHNldEluZGV4KGFyZ3MsIG9wdHMsIHJlc29sdmUsIHJlamVjdCkge1xuICAgIGlmIChvcHRzID09PSB2b2lkIDApIHsgb3B0cyA9IHt9OyB9XG4gICAgLy8gaWdub3JlIHJlc29sdmUgYW5kIHJlamVjdCBpbiBjYXNlIHN5bmNcbiAgICBpZiAob3B0cy5zeW5jKSB7XG4gICAgICAgIHJldHVybiBhcmdzO1xuICAgIH1cbiAgICAvLyBJZiB0aGUgcGx1Z2luIG1ldGhvZCBleHBlY3RzIG15TWV0aG9kKHN1Y2Nlc3MsIGVyciwgb3B0aW9ucylcbiAgICBpZiAob3B0cy5jYWxsYmFja09yZGVyID09PSAncmV2ZXJzZScpIHtcbiAgICAgICAgLy8gR2V0IHRob3NlIGFyZ3VtZW50cyBpbiB0aGUgb3JkZXIgW3Jlc29sdmUsIHJlamVjdCwgLi4ucmVzdE9mQXJnc11cbiAgICAgICAgYXJncy51bnNoaWZ0KHJlamVjdCk7XG4gICAgICAgIGFyZ3MudW5zaGlmdChyZXNvbHZlKTtcbiAgICB9XG4gICAgZWxzZSBpZiAob3B0cy5jYWxsYmFja1N0eWxlID09PSAnbm9kZScpIHtcbiAgICAgICAgYXJncy5wdXNoKGZ1bmN0aW9uIChlcnIsIHJlc3VsdCkge1xuICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZWxzZSBpZiAob3B0cy5jYWxsYmFja1N0eWxlID09PSAnb2JqZWN0JyAmJiBvcHRzLnN1Y2Nlc3NOYW1lICYmIG9wdHMuZXJyb3JOYW1lKSB7XG4gICAgICAgIHZhciBvYmogPSB7fTtcbiAgICAgICAgb2JqW29wdHMuc3VjY2Vzc05hbWVdID0gcmVzb2x2ZTtcbiAgICAgICAgb2JqW29wdHMuZXJyb3JOYW1lXSA9IHJlamVjdDtcbiAgICAgICAgYXJncy5wdXNoKG9iaik7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiBvcHRzLnN1Y2Nlc3NJbmRleCAhPT0gJ3VuZGVmaW5lZCcgfHwgdHlwZW9mIG9wdHMuZXJyb3JJbmRleCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgdmFyIHNldFN1Y2Nlc3NJbmRleCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIElmIHdlJ3ZlIHNwZWNpZmllZCBhIHN1Y2Nlc3MvZXJyb3IgaW5kZXhcbiAgICAgICAgICAgIGlmIChvcHRzLnN1Y2Nlc3NJbmRleCA+IGFyZ3MubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgYXJnc1tvcHRzLnN1Y2Nlc3NJbmRleF0gPSByZXNvbHZlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYXJncy5zcGxpY2Uob3B0cy5zdWNjZXNzSW5kZXgsIDAsIHJlc29sdmUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB2YXIgc2V0RXJyb3JJbmRleCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIFdlIGRvbid0IHdhbnQgdGhhdCB0aGUgcmVqZWN0IGNiIGdldHMgc3BsaWNlZCBpbnRvIHRoZSBwb3NpdGlvbiBvZiBhbiBvcHRpb25hbCBhcmd1bWVudCB0aGF0IGhhcyBub3QgYmVlblxuICAgICAgICAgICAgLy8gZGVmaW5lZCBhbmQgdGh1cyBjYXVzaW5nIG5vbiBleHBlY3RlZCBiZWhhdmlvci5cbiAgICAgICAgICAgIGlmIChvcHRzLmVycm9ySW5kZXggPiBhcmdzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGFyZ3Nbb3B0cy5lcnJvckluZGV4XSA9IHJlamVjdDsgLy8gaW5zZXJ0IHRoZSByZWplY3QgZm4gYXQgdGhlIGNvcnJlY3Qgc3BlY2lmaWMgaW5kZXhcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGFyZ3Muc3BsaWNlKG9wdHMuZXJyb3JJbmRleCwgMCwgcmVqZWN0KTsgLy8gb3RoZXJ3aXNlIGp1c3Qgc3BsaWNlIGl0IGludG8gdGhlIGFycmF5XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGlmIChvcHRzLnN1Y2Nlc3NJbmRleCA+IG9wdHMuZXJyb3JJbmRleCkge1xuICAgICAgICAgICAgc2V0RXJyb3JJbmRleCgpO1xuICAgICAgICAgICAgc2V0U3VjY2Vzc0luZGV4KCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzZXRTdWNjZXNzSW5kZXgoKTtcbiAgICAgICAgICAgIHNldEVycm9ySW5kZXgoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gT3RoZXJ3aXNlLCBsZXQncyB0YWNrIHRoZW0gb24gdG8gdGhlIGVuZCBvZiB0aGUgYXJndW1lbnQgbGlzdFxuICAgICAgICAvLyB3aGljaCBpcyA5MCUgb2YgY2FzZXNcbiAgICAgICAgYXJncy5wdXNoKHJlc29sdmUpO1xuICAgICAgICBhcmdzLnB1c2gocmVqZWN0KTtcbiAgICB9XG4gICAgcmV0dXJuIGFyZ3M7XG59XG5mdW5jdGlvbiBjYWxsQ29yZG92YVBsdWdpbihwbHVnaW5PYmosIG1ldGhvZE5hbWUsIGFyZ3MsIG9wdHMsIHJlc29sdmUsIHJlamVjdCkge1xuICAgIGlmIChvcHRzID09PSB2b2lkIDApIHsgb3B0cyA9IHt9OyB9XG4gICAgLy8gVHJ5IHRvIGZpZ3VyZSBvdXQgd2hlcmUgdGhlIHN1Y2Nlc3MvZXJyb3IgY2FsbGJhY2tzIG5lZWQgdG8gYmUgYm91bmRcbiAgICAvLyB0byBvdXIgcHJvbWlzZSByZXNvbHZlL3JlamVjdCBoYW5kbGVycy5cbiAgICBhcmdzID0gc2V0SW5kZXgoYXJncywgb3B0cywgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICB2YXIgYXZhaWxhYmlsaXR5Q2hlY2sgPSBjaGVja0F2YWlsYWJpbGl0eShwbHVnaW5PYmosIG1ldGhvZE5hbWUpO1xuICAgIGlmIChhdmFpbGFiaWxpdHlDaGVjayA9PT0gdHJ1ZSkge1xuICAgICAgICB2YXIgcGx1Z2luSW5zdGFuY2UgPSBnZXRQbHVnaW4ocGx1Z2luT2JqLmNvbnN0cnVjdG9yLmdldFBsdWdpblJlZigpKTtcbiAgICAgICAgcmV0dXJuIHBsdWdpbkluc3RhbmNlW21ldGhvZE5hbWVdLmFwcGx5KHBsdWdpbkluc3RhbmNlLCBhcmdzKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBhdmFpbGFiaWxpdHlDaGVjaztcbiAgICB9XG59XG5mdW5jdGlvbiBjYWxsSW5zdGFuY2UocGx1Z2luT2JqLCBtZXRob2ROYW1lLCBhcmdzLCBvcHRzLCByZXNvbHZlLCByZWplY3QpIHtcbiAgICBpZiAob3B0cyA9PT0gdm9pZCAwKSB7IG9wdHMgPSB7fTsgfVxuICAgIGFyZ3MgPSBzZXRJbmRleChhcmdzLCBvcHRzLCByZXNvbHZlLCByZWplY3QpO1xuICAgIGlmIChpbnN0YW5jZUF2YWlsYWJpbGl0eShwbHVnaW5PYmosIG1ldGhvZE5hbWUpKSB7XG4gICAgICAgIHJldHVybiBwbHVnaW5PYmouX29iamVjdEluc3RhbmNlW21ldGhvZE5hbWVdLmFwcGx5KHBsdWdpbk9iai5fb2JqZWN0SW5zdGFuY2UsIGFyZ3MpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGdldFBsdWdpbihwbHVnaW5SZWYpIHtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmV0dXJuIGdldCQxKHdpbmRvdywgcGx1Z2luUmVmKTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBnZXQkMShlbGVtZW50LCBwYXRoKSB7XG4gICAgdmFyIHBhdGhzID0gcGF0aC5zcGxpdCgnLicpO1xuICAgIHZhciBvYmogPSBlbGVtZW50O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGF0aHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKCFvYmopIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIG9iaiA9IG9ialtwYXRoc1tpXV07XG4gICAgfVxuICAgIHJldHVybiBvYmo7XG59XG5mdW5jdGlvbiBwbHVnaW5XYXJuKHBsdWdpbk5hbWUsIHBsdWdpbiwgbWV0aG9kKSB7XG4gICAgaWYgKG1ldGhvZCkge1xuICAgICAgICBjb25zb2xlLndhcm4oJ05hdGl2ZTogdHJpZWQgY2FsbGluZyAnICsgcGx1Z2luTmFtZSArICcuJyArIG1ldGhvZCArICcsIGJ1dCB0aGUgJyArIHBsdWdpbk5hbWUgKyAnIHBsdWdpbiBpcyBub3QgaW5zdGFsbGVkLicpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY29uc29sZS53YXJuKFwiTmF0aXZlOiB0cmllZCBhY2Nlc3NpbmcgdGhlIFwiICsgcGx1Z2luTmFtZSArIFwiIHBsdWdpbiBidXQgaXQncyBub3QgaW5zdGFsbGVkLlwiKTtcbiAgICB9XG4gICAgaWYgKHBsdWdpbikge1xuICAgICAgICBjb25zb2xlLndhcm4oXCJJbnN0YWxsIHRoZSBcIiArIHBsdWdpbk5hbWUgKyBcIiBwbHVnaW46ICdpb25pYyBjb3Jkb3ZhIHBsdWdpbiBhZGQgXCIgKyBwbHVnaW4gKyBcIidcIik7XG4gICAgfVxufVxuLyoqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHBsdWdpbk5hbWVcbiAqIEBwYXJhbSBtZXRob2RcbiAqL1xuZnVuY3Rpb24gY29yZG92YVdhcm4ocGx1Z2luTmFtZSwgbWV0aG9kKSB7XG4gICAgaWYgKHR5cGVvZiBwcm9jZXNzID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICBpZiAobWV0aG9kKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ05hdGl2ZTogdHJpZWQgY2FsbGluZyAnICtcbiAgICAgICAgICAgICAgICBwbHVnaW5OYW1lICtcbiAgICAgICAgICAgICAgICAnLicgK1xuICAgICAgICAgICAgICAgIG1ldGhvZCArXG4gICAgICAgICAgICAgICAgJywgYnV0IENvcmRvdmEgaXMgbm90IGF2YWlsYWJsZS4gTWFrZSBzdXJlIHRvIGluY2x1ZGUgY29yZG92YS5qcyBvciBydW4gaW4gYSBkZXZpY2Uvc2ltdWxhdG9yJyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ05hdGl2ZTogdHJpZWQgYWNjZXNzaW5nIHRoZSAnICtcbiAgICAgICAgICAgICAgICBwbHVnaW5OYW1lICtcbiAgICAgICAgICAgICAgICAnIHBsdWdpbiBidXQgQ29yZG92YSBpcyBub3QgYXZhaWxhYmxlLiBNYWtlIHN1cmUgdG8gaW5jbHVkZSBjb3Jkb3ZhLmpzIG9yIHJ1biBpbiBhIGRldmljZS9zaW11bGF0b3InKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8qKlxuICogQHByaXZhdGVcbiAqL1xudmFyIHdyYXAgPSBmdW5jdGlvbiAocGx1Z2luT2JqLCBtZXRob2ROYW1lLCBvcHRzKSB7XG4gICAgaWYgKG9wdHMgPT09IHZvaWQgMCkgeyBvcHRzID0ge307IH1cbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYXJncyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRzLnN5bmMpIHtcbiAgICAgICAgICAgIC8vIFN5bmMgZG9lc24ndCB3cmFwIHRoZSBwbHVnaW4gd2l0aCBhIHByb21pc2Ugb3Igb2JzZXJ2YWJsZSwgaXQgcmV0dXJucyB0aGUgcmVzdWx0IGFzLWlzXG4gICAgICAgICAgICByZXR1cm4gY2FsbENvcmRvdmFQbHVnaW4ocGx1Z2luT2JqLCBtZXRob2ROYW1lLCBhcmdzLCBvcHRzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChvcHRzLm9ic2VydmFibGUpIHtcbiAgICAgICAgICAgIHJldHVybiB3cmFwT2JzZXJ2YWJsZShwbHVnaW5PYmosIG1ldGhvZE5hbWUsIGFyZ3MsIG9wdHMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG9wdHMuZXZlbnRPYnNlcnZhYmxlICYmIG9wdHMuZXZlbnQpIHtcbiAgICAgICAgICAgIHJldHVybiB3cmFwRXZlbnRPYnNlcnZhYmxlKG9wdHMuZXZlbnQsIG9wdHMuZWxlbWVudCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob3B0cy5vdGhlclByb21pc2UpIHtcbiAgICAgICAgICAgIHJldHVybiB3cmFwT3RoZXJQcm9taXNlKHBsdWdpbk9iaiwgbWV0aG9kTmFtZSwgYXJncywgb3B0cyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gd3JhcFByb21pc2UocGx1Z2luT2JqLCBtZXRob2ROYW1lLCBhcmdzLCBvcHRzKTtcbiAgICAgICAgfVxuICAgIH07XG59O1xuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiB3cmFwSW5zdGFuY2UocGx1Z2luT2JqLCBtZXRob2ROYW1lLCBvcHRzKSB7XG4gICAgaWYgKG9wdHMgPT09IHZvaWQgMCkgeyBvcHRzID0ge307IH1cbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYXJncyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRzLnN5bmMpIHtcbiAgICAgICAgICAgIHJldHVybiBjYWxsSW5zdGFuY2UocGx1Z2luT2JqLCBtZXRob2ROYW1lLCBhcmdzLCBvcHRzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChvcHRzLm9ic2VydmFibGUpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgcnhqcy5PYnNlcnZhYmxlKGZ1bmN0aW9uIChvYnNlcnZlcikge1xuICAgICAgICAgICAgICAgIHZhciBwbHVnaW5SZXN1bHQ7XG4gICAgICAgICAgICAgICAgaWYgKG9wdHMuZGVzdHJ1Y3QpIHtcbiAgICAgICAgICAgICAgICAgICAgcGx1Z2luUmVzdWx0ID0gY2FsbEluc3RhbmNlKHBsdWdpbk9iaiwgbWV0aG9kTmFtZSwgYXJncywgb3B0cywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9ic2VydmVyLm5leHQoYXJncyk7XG4gICAgICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhcmdzID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBvYnNlcnZlci5lcnJvcihhcmdzKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBwbHVnaW5SZXN1bHQgPSBjYWxsSW5zdGFuY2UocGx1Z2luT2JqLCBtZXRob2ROYW1lLCBhcmdzLCBvcHRzLCBvYnNlcnZlci5uZXh0LmJpbmQob2JzZXJ2ZXIpLCBvYnNlcnZlci5lcnJvci5iaW5kKG9ic2VydmVyKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChwbHVnaW5SZXN1bHQgJiYgcGx1Z2luUmVzdWx0LmVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIG9ic2VydmVyLmVycm9yKHBsdWdpblJlc3VsdC5lcnJvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob3B0cy5jbGVhcldpdGhBcmdzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxJbnN0YW5jZShwbHVnaW5PYmosIG9wdHMuY2xlYXJGdW5jdGlvbiwgYXJncywgb3B0cywgb2JzZXJ2ZXIubmV4dC5iaW5kKG9ic2VydmVyKSwgb2JzZXJ2ZXIuZXJyb3IuYmluZChvYnNlcnZlcikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxJbnN0YW5jZShwbHVnaW5PYmosIG9wdHMuY2xlYXJGdW5jdGlvbiwgW10pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ1VuYWJsZSB0byBjbGVhciB0aGUgcHJldmlvdXMgb2JzZXJ2YWJsZSB3YXRjaCBmb3InLCBwbHVnaW5PYmouY29uc3RydWN0b3IuZ2V0UGx1Z2luTmFtZSgpLCBtZXRob2ROYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChvcHRzLm90aGVyUHJvbWlzZSkge1xuICAgICAgICAgICAgcmV0dXJuIGdldFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgICAgIHZhciByZXN1bHQ7XG4gICAgICAgICAgICAgICAgaWYgKG9wdHMuZGVzdHJ1Y3QpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gY2FsbEluc3RhbmNlKHBsdWdpbk9iaiwgbWV0aG9kTmFtZSwgYXJncywgb3B0cywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUoYXJncyk7XG4gICAgICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhcmdzID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZWplY3QoYXJncyk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gY2FsbEluc3RhbmNlKHBsdWdpbk9iaiwgbWV0aG9kTmFtZSwgYXJncywgb3B0cywgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdCAmJiByZXN1bHQudGhlbikge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQudGhlbihyZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgcGx1Z2luUmVzdWx0XzEsIHJlal8xO1xuICAgICAgICAgICAgdmFyIHAgPSBnZXRQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgICAgICBpZiAob3B0cy5kZXN0cnVjdCkge1xuICAgICAgICAgICAgICAgICAgICBwbHVnaW5SZXN1bHRfMSA9IGNhbGxJbnN0YW5jZShwbHVnaW5PYmosIG1ldGhvZE5hbWUsIGFyZ3MsIG9wdHMsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhcmdzID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZlKGFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYXJncyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0KGFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHBsdWdpblJlc3VsdF8xID0gY2FsbEluc3RhbmNlKHBsdWdpbk9iaiwgbWV0aG9kTmFtZSwgYXJncywgb3B0cywgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVqXzEgPSByZWplY3Q7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIEFuZ3VsYXIgdGhyb3dzIGFuIGVycm9yIG9uIHVuaGFuZGxlZCByZWplY3Rpb24sIGJ1dCBpbiB0aGlzIGNhc2Ugd2UgaGF2ZSBhbHJlYWR5IHByaW50ZWRcbiAgICAgICAgICAgIC8vIGEgd2FybmluZyB0aGF0IENvcmRvdmEgaXMgdW5kZWZpbmVkIG9yIHRoZSBwbHVnaW4gaXMgdW5pbnN0YWxsZWQsIHNvIHRoZXJlIGlzIG5vIHJlYXNvblxuICAgICAgICAgICAgLy8gdG8gZXJyb3JcbiAgICAgICAgICAgIGlmIChwbHVnaW5SZXN1bHRfMSAmJiBwbHVnaW5SZXN1bHRfMS5lcnJvcikge1xuICAgICAgICAgICAgICAgIHAuY2F0Y2goZnVuY3Rpb24gKCkgeyB9KTtcbiAgICAgICAgICAgICAgICB0eXBlb2YgcmVqXzEgPT09ICdmdW5jdGlvbicgJiYgcmVqXzEocGx1Z2luUmVzdWx0XzEuZXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHA7XG4gICAgICAgIH1cbiAgICB9O1xufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGdldChlbGVtZW50LCBwYXRoKSB7XG4gICAgdmFyIHBhdGhzID0gcGF0aC5zcGxpdCgnLicpO1xuICAgIHZhciBvYmogPSBlbGVtZW50O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGF0aHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKCFvYmopIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIG9iaiA9IG9ialtwYXRoc1tpXV07XG4gICAgfVxuICAgIHJldHVybiBvYmo7XG59XG5cbnZhciBJb25pY05hdGl2ZVBsdWdpbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBJb25pY05hdGl2ZVBsdWdpbigpIHtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIGJvb2xlYW4gdGhhdCBpbmRpY2F0ZXMgd2hldGhlciB0aGUgcGx1Z2luIGlzIGluc3RhbGxlZFxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAgICovXG4gICAgSW9uaWNOYXRpdmVQbHVnaW4uaW5zdGFsbGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgaXNBdmFpbGFibGUgPSBjaGVja0F2YWlsYWJpbGl0eSh0aGlzLnBsdWdpblJlZikgPT09IHRydWU7XG4gICAgICAgIHJldHVybiBpc0F2YWlsYWJsZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIG9yaWdpbmFsIHBsdWdpbiBvYmplY3RcbiAgICAgKi9cbiAgICBJb25pY05hdGl2ZVBsdWdpbi5nZXRQbHVnaW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcmV0dXJuIGdldCh3aW5kb3csIHRoaXMucGx1Z2luUmVmKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHBsdWdpbidzIG5hbWVcbiAgICAgKi9cbiAgICBJb25pY05hdGl2ZVBsdWdpbi5nZXRQbHVnaW5OYW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcGx1Z2luTmFtZSA9IHRoaXMucGx1Z2luTmFtZTtcbiAgICAgICAgcmV0dXJuIHBsdWdpbk5hbWU7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBwbHVnaW4ncyByZWZlcmVuY2VcbiAgICAgKi9cbiAgICBJb25pY05hdGl2ZVBsdWdpbi5nZXRQbHVnaW5SZWYgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBwbHVnaW5SZWYgPSB0aGlzLnBsdWdpblJlZjtcbiAgICAgICAgcmV0dXJuIHBsdWdpblJlZjtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHBsdWdpbidzIGluc3RhbGwgbmFtZVxuICAgICAqL1xuICAgIElvbmljTmF0aXZlUGx1Z2luLmdldFBsdWdpbkluc3RhbGxOYW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcGx1Z2luID0gdGhpcy5wbHVnaW47XG4gICAgICAgIHJldHVybiBwbHVnaW47XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBwbHVnaW4ncyBzdXBwb3J0ZWQgcGxhdGZvcm1zXG4gICAgICovXG4gICAgSW9uaWNOYXRpdmVQbHVnaW4uZ2V0U3VwcG9ydGVkUGxhdGZvcm1zID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcGxhdGZvcm0gPSB0aGlzLnBsYXRmb3JtcztcbiAgICAgICAgcmV0dXJuIHBsYXRmb3JtO1xuICAgIH07XG4gICAgSW9uaWNOYXRpdmVQbHVnaW4ucGx1Z2luTmFtZSA9ICcnO1xuICAgIElvbmljTmF0aXZlUGx1Z2luLnBsdWdpblJlZiA9ICcnO1xuICAgIElvbmljTmF0aXZlUGx1Z2luLnBsdWdpbiA9ICcnO1xuICAgIElvbmljTmF0aXZlUGx1Z2luLnJlcG8gPSAnJztcbiAgICBJb25pY05hdGl2ZVBsdWdpbi5wbGF0Zm9ybXMgPSBbXTtcbiAgICBJb25pY05hdGl2ZVBsdWdpbi5pbnN0YWxsID0gJyc7XG4gICAgcmV0dXJuIElvbmljTmF0aXZlUGx1Z2luO1xufSgpKTtcblxuZnVuY3Rpb24gY29yZG92YShwbHVnaW5PYmosIG1ldGhvZE5hbWUsIGNvbmZpZywgYXJncykge1xuICAgIHJldHVybiB3cmFwKHBsdWdpbk9iaiwgbWV0aG9kTmFtZSwgY29uZmlnKS5hcHBseSh0aGlzLCBhcmdzKTtcbn1cblxuZnVuY3Rpb24gb3ZlcnJpZGVGdW5jdGlvbihwbHVnaW5PYmosIG1ldGhvZE5hbWUpIHtcbiAgICByZXR1cm4gbmV3IHJ4anMuT2JzZXJ2YWJsZShmdW5jdGlvbiAob2JzZXJ2ZXIpIHtcbiAgICAgICAgdmFyIGF2YWlsYWJpbGl0eUNoZWNrID0gY2hlY2tBdmFpbGFiaWxpdHkocGx1Z2luT2JqLCBtZXRob2ROYW1lKTtcbiAgICAgICAgaWYgKGF2YWlsYWJpbGl0eUNoZWNrID09PSB0cnVlKSB7XG4gICAgICAgICAgICB2YXIgcGx1Z2luSW5zdGFuY2VfMSA9IGdldFBsdWdpbihwbHVnaW5PYmouY29uc3RydWN0b3IuZ2V0UGx1Z2luUmVmKCkpO1xuICAgICAgICAgICAgcGx1Z2luSW5zdGFuY2VfMVttZXRob2ROYW1lXSA9IG9ic2VydmVyLm5leHQuYmluZChvYnNlcnZlcik7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkgeyByZXR1cm4gKHBsdWdpbkluc3RhbmNlXzFbbWV0aG9kTmFtZV0gPSBmdW5jdGlvbiAoKSB7IH0pOyB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgb2JzZXJ2ZXIuZXJyb3IoYXZhaWxhYmlsaXR5Q2hlY2spO1xuICAgICAgICAgICAgb2JzZXJ2ZXIuY29tcGxldGUoKTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuZnVuY3Rpb24gY29yZG92YUZ1bmN0aW9uT3ZlcnJpZGUocGx1Z2luT2JqLCBtZXRob2ROYW1lLCBhcmdzKSB7XG4gICAgcmV0dXJuIG92ZXJyaWRlRnVuY3Rpb24ocGx1Z2luT2JqLCBtZXRob2ROYW1lKTtcbn1cblxuZnVuY3Rpb24gY29yZG92YUluc3RhbmNlKHBsdWdpbk9iaiwgbWV0aG9kTmFtZSwgY29uZmlnLCBhcmdzKSB7XG4gICAgYXJncyA9IEFycmF5LmZyb20oYXJncyk7XG4gICAgcmV0dXJuIHdyYXBJbnN0YW5jZShwbHVnaW5PYmosIG1ldGhvZE5hbWUsIGNvbmZpZykuYXBwbHkodGhpcywgYXJncyk7XG59XG5cbmZ1bmN0aW9uIGNvcmRvdmFQcm9wZXJ0eUdldChwbHVnaW5PYmosIGtleSkge1xuICAgIGlmIChjaGVja0F2YWlsYWJpbGl0eShwbHVnaW5PYmosIGtleSkgPT09IHRydWUpIHtcbiAgICAgICAgcmV0dXJuIGdldFBsdWdpbihwbHVnaW5PYmouY29uc3RydWN0b3IuZ2V0UGx1Z2luUmVmKCkpW2tleV07XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gY29yZG92YVByb3BlcnR5U2V0KHBsdWdpbk9iaiwga2V5LCB2YWx1ZSkge1xuICAgIGlmIChjaGVja0F2YWlsYWJpbGl0eShwbHVnaW5PYmosIGtleSkgPT09IHRydWUpIHtcbiAgICAgICAgZ2V0UGx1Z2luKHBsdWdpbk9iai5jb25zdHJ1Y3Rvci5nZXRQbHVnaW5SZWYoKSlba2V5XSA9IHZhbHVlO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gaW5zdGFuY2VQcm9wZXJ0eUdldChwbHVnaW5PYmosIGtleSkge1xuICAgIGlmIChwbHVnaW5PYmouX29iamVjdEluc3RhbmNlICYmIHBsdWdpbk9iai5fb2JqZWN0SW5zdGFuY2Vba2V5XSkge1xuICAgICAgICByZXR1cm4gcGx1Z2luT2JqLl9vYmplY3RJbnN0YW5jZVtrZXldO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGluc3RhbmNlUHJvcGVydHlTZXQocGx1Z2luT2JqLCBrZXksIHZhbHVlKSB7XG4gICAgaWYgKHBsdWdpbk9iai5fb2JqZWN0SW5zdGFuY2UpIHtcbiAgICAgICAgcGx1Z2luT2JqLl9vYmplY3RJbnN0YW5jZVtrZXldID0gdmFsdWU7XG4gICAgfVxufVxuXG5jaGVja1JlYWR5KCk7XG5cbmV4cG9ydHMuSW9uaWNOYXRpdmVQbHVnaW4gPSBJb25pY05hdGl2ZVBsdWdpbjtcbmV4cG9ydHMuY2hlY2tBdmFpbGFiaWxpdHkgPSBjaGVja0F2YWlsYWJpbGl0eTtcbmV4cG9ydHMuY29yZG92YSA9IGNvcmRvdmE7XG5leHBvcnRzLmNvcmRvdmFGdW5jdGlvbk92ZXJyaWRlID0gY29yZG92YUZ1bmN0aW9uT3ZlcnJpZGU7XG5leHBvcnRzLmNvcmRvdmFJbnN0YW5jZSA9IGNvcmRvdmFJbnN0YW5jZTtcbmV4cG9ydHMuY29yZG92YVByb3BlcnR5R2V0ID0gY29yZG92YVByb3BlcnR5R2V0O1xuZXhwb3J0cy5jb3Jkb3ZhUHJvcGVydHlTZXQgPSBjb3Jkb3ZhUHJvcGVydHlTZXQ7XG5leHBvcnRzLmdldFByb21pc2UgPSBnZXRQcm9taXNlO1xuZXhwb3J0cy5pbnN0YW5jZUF2YWlsYWJpbGl0eSA9IGluc3RhbmNlQXZhaWxhYmlsaXR5O1xuZXhwb3J0cy5pbnN0YW5jZVByb3BlcnR5R2V0ID0gaW5zdGFuY2VQcm9wZXJ0eUdldDtcbmV4cG9ydHMuaW5zdGFuY2VQcm9wZXJ0eVNldCA9IGluc3RhbmNlUHJvcGVydHlTZXQ7XG5leHBvcnRzLndyYXAgPSB3cmFwO1xuIl19